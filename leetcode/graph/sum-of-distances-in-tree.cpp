#include <vector>
using namespace std;
/**
* 树中距离之和：https://leetcode.cn/problems/sum-of-distances-in-tree/
* 
* 不完善的思路：
*	1.1 <= n <= 3 * 10^4。暴力解，获取一个节点的距离和，就要以该节点为根节点，遍历整颗树。遍历整颗树的时间是n。
*	  但是获取所有节点的距离，时间复杂度，就上升至O(n^2)了。
*	2.想办法优化时间复杂度：有没有办法先计算以某个节点为根节点，计算距离和。然后以此，快速推算其他点的距离和。
*	3.想一想，在遍历一颗树的时候，我们能获得什么？树的高度、前中后序、树的深度、【左子树、右子树大小，或者说节点数目】
*	4.（错误：没有注意到，如示例一，这不是个二叉树，而是N叉树）知道左右子树节点数目，当将根节点，移动到左节点时，
*	  左节点的距离和，必然要减少（左节点的子树节点数目 - 1）(距离拉近了)，加上（右节点的子树节点数目 + 1）(包括原根节点)
* 
*	  正确思路：定义dp[u]表示以u为根的子树，它的所有子节点到它的距离之和，同时定义sz[u]表示以u为根的子树的节点数量（包括了u）。
*	  则			dp[u] = dp[v1] + sz[v1] + dp[v2] + sz[v2] + ...  (v1、v2是u的直接子节点)
*					sz[u] = sz[v1] + sz[v2]
*     我们遍历整棵树，自底向上，即可得到dp[root]
*	5.怎么构建树（这一点没有想明白）
*		1.edges并没有保证节点0就是根节点，也强调了树是无向的。所以无法以传统的方式，简单建立左节点、右节点这样的树类结构。
*		  以edges建图，只能建立无向图。
*	6.怎么遍历树（无向图）：有去无回法――检查是否是parent，是则跳过。如果只有一条边，那只能是parent了，可以确定到了树的根部。
*	7.状态转移：转移根节点，u->v
*		v不为u提供任何贡献了，所以			dp[u] = dp[u] - (dp[v] + sz[v])
*											sz[u] = sz[u] - sz[v]
*       u为新的根节点v提供了贡献，所以		dp[v] = dp[v] + (dp[u] + sz[u])
*											sz[v] = sz[v] + sz[u]
*/
class Solution {
public:
	vector<int> sumOfDistancesInTree(int n, vector<vector<int>>& edges) {

	}
};

int main() {

}